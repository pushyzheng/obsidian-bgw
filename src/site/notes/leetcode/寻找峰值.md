---
{"dg-publish":true,"dg-permalink":"寻找峰值","permalink":"/寻找峰值/","title":"寻找峰值","tags":["二分查找"]}
---


比较当前 mid 元素和 mid + 1（右侧相邻元素），两种情况：
1. 比右边小
	- 说明还**没到顶峰**，右边一定有顶峰，最坏的情况走到头，也是一个峰顶
	- 继续向**右**查找
2. 比左边小
	- 说明**左边**有顶峰，或者 mid 本身就是顶峰
	- 继续向**左**查找，且包括当前 mid 值，所以是 `right = mid`

## Go

```go
func findPeakElement(nums []int) int {
	left, right := 0, len(nums)-1
	for left < right {
		mid := left + (right-left)/2
		if nums[mid] <= nums[mid+1] {
			left = mid + 1
		} else {
			// 由于这个情况下，mid 本身也有可能是峰值元素
			// 所以不能使用 right = mid -1，这样会丢弃 mid 本身
			right = mid
		}
	}
	return left
}
```

## Java

```java
public int findPeakElement(int[] nums) {
    if (nums == null || nums.length == 0) return -1;

    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= nums[mid + 1]) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

类似题：
- [[leetcode/第一个错误的版本\|第一个错误的版本]]
