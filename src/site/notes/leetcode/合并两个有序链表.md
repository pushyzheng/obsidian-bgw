---
{"dg-publish":true,"dg-permalink":"合并两个有序链表","permalink":"/合并两个有序链表/","title":"合并两个有序链表","tags":["链表"]}
---


#算法

## 迭代

- 同时遍历两个链表即可，优先将大的放置在新的链表上
- 终止条件为 `l1 != null && l2 != null`，需要进行后置处理

### Go

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
	if list1 == nil {
		return list2
	}
	if list2 == nil {
		return list1
	}

	dummy := &ListNode{Val: -1}
	cur := dummy
	for list1 != nil && list2 != nil {
		if list1.Val > list2.Val {
			cur.Next = list2
			list2 = list2.Next
		} else {
			cur.Next = list1
			list1 = list1.Next
		}
		cur = cur.Next
	}
	// 考虑 list1 和 list2 长度不一致的情况
	if list1 != nil {
		cur.Next = list1
	} else {
		cur.Next = list2
	}
	return dummy.Next
}
```

### Java

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	if(l1==null) return l2;
	if(l2==null) return l1;

	ListNode dummy=new ListNode(-1);
	ListNode result=dummy;
	while(l1!=null && l2!=null){
		if(l1.val>l2.val){
			result.next=l2;
			l2=l2.next;
		} else {
			result.next=l1;
			l1=l1.next;
		}
		result=result.next;
	}
	// 处理两个链表长度不相同的情况
	result.next=l1==null?l2:l1;
	return dummy.next;
}
```

## 递归

判断 l1 和 l2 头结点哪个更小，然后较小结点的 next 指针指向其余结点的合并结果

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
	if (l1 == null) {
		return l2;
	} else if (l2 == null) {
		return l1;
	} else if (l1.val < l2.val) {
		l1.next = mergeTwoLists(l1.next, l2);
		return l1;
	} else {
		l2.next = mergeTwoLists(l1, l2.next);
		return l2;
	}
}
```