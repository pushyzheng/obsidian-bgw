---
{"dg-publish":true,"dg-permalink":"从前序与中序遍历序列构造二叉树","permalink":"/从前序与中序遍历序列构造二叉树/","title":"从前序与中序遍历序列构造二叉树","tags":["二叉树","构造二叉树"]}
---


## 思路

![Pasted image 20251018162040.png|400](/img/user/attachments/images/Pasted%20image%2020251018162040.png)

前序遍历和中序遍历的特点：
1. 前序遍历**第一**个值就是根节点的值
2. 通过根节点的值，在后序遍历数组中将左右子树**分开**
3. 划分区间
	- preorder
		- `leftSize = index - inStart`
		- 左：`preStart, preStart + leftSize`
		- 右：`preStart + leftSize + 1, preEnd`
	- inorder
		- 左：`inStart, index - 1`
		- 右：`index +1, inEnd`

![Pasted image 20251018162826.png|400](/img/user/attachments/images/Pasted%20image%2020251018162826.png)

## 代码

由于需要快速找到根结点在中序遍历的下标，所以可以先创建中序遍历的**结点值 -> 数组下标**的哈希表

### Go

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
	mp := make(map[int]int, len(inorder))
	for i, val := range inorder {
		mp[val] = i
	}

	var build func(int, int, int, int) *TreeNode
	build = func(preStart int, preEnd int, inStart int, inEnd int) *TreeNode {
		if preStart > preEnd {
			return nil
		}
		rootVal := preorder[preStart]
		index := mp[rootVal]
		leftSize := index - inStart
		// 构造节点以及左右子树
		root := &TreeNode{Val: rootVal}
		root.Left = build(preStart+1, preStart+leftSize, inStart, index-1)
		root.Right = build(preStart+leftSize+1, preEnd, index+1, inEnd)
		return root
	}
	return build(0, len(preorder)-1, 0, len(inorder)-1)
}
```

### Java

```java
private Map<Integer, Integer> map;

public TreeNode buildTree(int[] preorder, int[] inorder) {
	map = new HashMap<>();
	for (int i = 0; i < inorder.length; i++) {
		map.put(inorder[i], i);
	}
	return buildTree(preorder, 0, preorder.length,
			inorder, 0, inorder.length);
}

private TreeNode buildTree(int[] preorder, int pStart, int pEnd,
						   int[] inorder, int inStart, int inEnd) {
	if (pStart == pEnd) return null;

	// 前序遍历第一个元素为根结点
	int rootVal = preorder[pStart];
	TreeNode root = new TreeNode(rootVal);
	// 获取在中序遍历数组内根结点的下标
	int rootIndex = map.get(rootVal);

	int leftNum = rootIndex - inStart;
	root.left = buildTree(preorder, pStart + 1, pStart + leftNum + 1,
			inorder, inStart, rootIndex);
	root.right = buildTree(preorder, pStart + leftNum + 1, pEnd,
			inorder, rootIndex + 1, inEnd);
	return root;
}
```