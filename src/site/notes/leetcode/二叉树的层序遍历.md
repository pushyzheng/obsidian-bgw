---
{"dg-publish":true,"dg-permalink":"二叉树的层序遍历","permalink":"/二叉树的层序遍历/","tags":["二叉树","树","BFS"]}
---


## 思路

[[src/数据结构和算法/BFS#概念\|BFS#概念]]

## 代码

```go
func levelOrder(root *TreeNode) [][]int {
	if root == nil {
		return nil
	}

	queue := []*TreeNode{root}
	var res [][]int
	for len(queue) > 0 {
		var level []int
		n := len(queue)  // 需要声明变量，否则在循环的时候 len(queue) 会变化
		for i := 0; i < n; i++ {
			node := queue[0]
			queue = queue[1:] // 出栈
			level = append(level, node.Val)
			
			// 空节点不要入队
			if node.Left != nil {
				queue = append(queue, node.Left)
			}
			if node.Right != nil {
				queue = append(queue, node.Right)
			}
		}
		res = append(res, level)
	}
	return res
}
```

Java：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
	Queue<TreeNode> queue = new LinkedList<>();
	List<List<Integer>> res = new ArrayList<>();
	if (root != null) queue.add(root);
	
	while (!queue.isEmpty()) {
		List<Integer> tmp = new ArrayList<>();
		for(int i = queue.size(); i > 0; i--) {
			TreeNode node = queue.poll();
			tmp.add(node.val);
			if (node.left != null) queue.add(node.left);
			if (node.right != null) queue.add(node.right);
		}
		res.add(tmp);
	}
	return res;
}
```