---
{"dg-publish":true,"dg-permalink":"全排列","permalink":"/全排列/","tags":["数组","全排列","回溯"]}
---


#算法

最经典的全排列，即**遍历这颗回溯树**即可，获取到所有路径：

![Pasted image 20220923160659.png|600](/img/user/attachments/images/Pasted%20image%2020220923160659.png)

1. 剪枝：使用哈希表来标记**访问过**的元素，避免重复使用
2. 进行选择：遍历 nums 数组，调用 backtrach 来进行递归的排列选择
3. 回溯：对 path 进行还原路径

## 代码

```go
func permute(nums []int) [][]int {
	var res [][]int
	mp := make(map[int]bool, len(nums))

	var backtrack func([]int, []int)
	backtrack = func(nums []int, path []int) {
		if len(path) == len(nums) {
			res = append(res, slices.Clone(path))
			return
		}
		for _, num := range nums {
			if mp[num] {
				continue // 剪枝
			}
			mp[num] = true
			path = append(path, num)
			backtrack(nums, path)
			path = path[:len(path)-1] // 回溯
			mp[num] = false           // 记得这里也还原
		}
	}
	backtrack(nums, nil)
	return res
}
```

Java：

```java
List<List<Integer>> res;

boolean[] used;

public List<List<Integer>> permute(int[] nums) {
	used=new boolean[nums.length];
	res=new ArrayList<>();
	backtrack(nums, new ArrayList<>());
	return res;
}

void backtrack(int[] nums, List<Integer> path) {
	if (path.size() == nums.length) {
		res.add(new ArrayList<>(path));
		return;
	}
	// 选择
	for(int i = 0; i<nums.length;i++) {
		if (!used[i]) {
			used[i] = true;
			path.add(nums[i]);
			backtrack(nums, path);
			// backtrack
			path.remove(path.size()- 1);
			used[i] = false;
		}
	}
}
```