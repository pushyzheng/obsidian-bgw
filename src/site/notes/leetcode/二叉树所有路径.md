---
{"dg-publish":true,"dg-permalink":"二叉树所有路径","permalink":"/二叉树所有路径/","tags":["二叉树","树","回溯"]}
---


## 思路

1. 回溯
	- 如果递归到叶子结点，将当前路径设置到结果中
	- 否则递归左子树、右子树
	- 在回溯的过程中，需要将 path 路径**进行清理**，还原上一层的路径情况

## 代码

### Go

递归写法：

```go
func binaryTreePaths(root *TreeNode) []string {
	var res []string

	var dfs func(root *TreeNode, path string)
	dfs = func(root *TreeNode, path string) {
		if root == nil {
			return
		}
		path += strconv.Itoa(root.Val)
		if root.Left == nil && root.Right == nil {
			res = append(res, path)
			return
		}
		path += "->"
		dfs(root.Left, path)
		dfs(root.Right, path)
	}

	dfs(root, "")
	return res
}
```

回溯写法：

```go
func binaryTreePaths(root *TreeNode) []string {
	var path, res []string

	var dfs func(root *TreeNode)
	dfs = func(root *TreeNode) {
		if root == nil {
			return
		}
		path = append(path, strconv.Itoa(root.Val))
		if root.Left == nil && root.Right == nil { // 叶子结点
			res = append(res, strings.Join(path, "->"))
		} else {
			dfs(root.Left)
			dfs(root.Right)
		}
		// 回溯
		path = path[:len(path)-1]
	}

	dfs(root)
	return res
}
```

### Java

```java
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> ans = new ArrayList<>();
        List<String> path = new ArrayList<>();
        dfs(root, ans, path);
        return ans;
    }

    private void dfs(TreeNode node, List<String> ans, List<String> path) {
        if (node == null) {
            return;
        }
        path.add(String.valueOf(node.val));
        if (node.left == null && node.right == null) { // 叶子节点
            ans.add(String.join("->", path));
        } else {
            dfs(node.left, ans, path);
            dfs(node.right, ans, path);
        }
        // 恢复现场，撤销上面的 path.add(String.valueOf(node.val));
        path.remove(path.size() - 1);
    }
}
```