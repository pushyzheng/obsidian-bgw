---
{"dg-publish":true,"dg-permalink":"下一个更大元素","permalink":"/下一个更大元素/","title":"下一个更大元素","tags":["栈","单调栈"]}
---


#算法 

## 思路

步骤：
1. 高效地去计算 nums2 每个元素右边第一个更大的值
	- 维护一个**单调递增栈**
2. 如何存储第一个子问题的值
	- 将第一次遍历 nums2 的值，存储到**哈希表**中
3. 遍历 nums1，从哈希表中获取到答案
	- 注意：这是因为 nums1 是 nums2 的**子集**，所以可以直接从哈希表中获取到全集的答案啊

## Go

```go
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	stack := []int{}     // 单调递增栈
	mp := map[int]int{}

	// 反向遍历 nums2
	for i := len(nums2) - 1; i >= 0; i-- {
		num := nums2[i]
		for len(stack) > 0 && num >= stack[len(stack)-1] {
			stack = stack[:len(stack)-1]
		}
		// 存储答案
		if len(stack) > 0 {
			mp[num] = stack[len(stack)-1]
		} else {
			mp[num] = -1
		}
		stack = append(stack, num)
	}
	// 从哈希表中获取到 nums2 的答案
	res := make([]int, len(nums1))
	for i, num := range nums1 {
		res[i] = mp[num]
	}
	return res 
}
```

## Java

```java
public int[] nextGreaterElement(int[] nums1, int[] nums2) {  
    Map<Integer, Integer> map = new HashMap<>();  
    Deque<Integer> stack = new LinkedList<>();  
    for (int i = 0; i < nums2.length; i++) {  
        while (!stack.isEmpty() && stack.peek() < nums2[i]) {  
            int top = stack.pop();  
            map.put(top, nums2[i]);  
        }  
        stack.push(nums2[i]);  
    }  
  
    int[] result = new int[nums1.length];  
    for (int i = 0; i < nums1.length; i++) {  
        result[i] = map.getOrDefault(nums1[i], -1);  
    }  
    return result;  
}
```