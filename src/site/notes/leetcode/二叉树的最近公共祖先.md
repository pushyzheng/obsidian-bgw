---
{"dg-publish":true,"dg-permalink":"二叉树的最近公共祖先","permalink":"/二叉树的最近公共祖先/","tags":["树","二叉树"]}
---


## 思路

![Pasted image 20220902170305.png|400](/img/user/attachments/images/Pasted%20image%2020220902170305.png)

在左右子树中查找：
- 如果在左右子树中，如果同时找到，则**当前结点为 LCA**（遍历到结点 5 的情况）
- 否则为左子树或右子树（遍历到根结点 3 的情况）

比较特殊的情况是正好 q 是 p 的祖先，即 q 是 LCA，如下图所示：

![Pasted image 20220902170015.png|400](/img/user/attachments/images/Pasted%20image%2020220902170015.png)

针对这种情况：
1. 需要在前序时判断 `root == v1 || root == v2`
2. 能断定 **p 一定在 q 的子树中**，则 q 为 LCA

## 代码

套用 [[src/数据结构和算法/在二叉树中寻找两个目标值结点模板\|在二叉树中寻找两个目标值结点模板]]

### Go

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	if root == nil || root == q || root == p {
		// p、q 本身是 LCA 的情况
		return root
	}
	left := lowestCommonAncestor(root.Left, p, q)
	right := lowestCommonAncestor(root.Right, p, q)
	if left != nil && right != nil {
        // p、q 分别分布在该结点的左右子树，则当前结点就是 LCA
		return root
	}
    // 如果只有左子树找到，就返回左子树的返回值
    // 如果只有右子树找到，就返回右子树的返回值
	if left != nil {
		return left
	}
	return right
}
```

### Java

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    return find(root, p.val, q.val);
}

TreeNode find(TreeNode root, int v1, int v2) {
    if (root == null) return null;
    if (root.val == v1 || root.val == v2) {
        return root;
    }
    TreeNode left = find(root.left, v1, v2);
    TreeNode right = find(root.right, v1, v2);
    if (left != null && right != null) {
        return root;
    }
    return left != null ? left : right;
}
```

另一种思路：[计算 p、q 两个路径后再比较](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-pushy-hzvb/)