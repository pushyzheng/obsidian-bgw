---
{"dg-publish":true,"dg-permalink":"在排序数组中查找元素的第一个和最后一个位置","permalink":"/在排序数组中查找元素的第一个和最后一个位置/","title":"在排序数组中查找元素的第一个和最后一个位置","tags":["二分查找"]}
---


## 思路

即：在一个**存在重复元素**的有序数组，寻找目标元素的：
1. 第一个出现的位置：等于时也向**左**查找
2. 最后一个出现的位置：等于时也向**右**查找

## Go

```go
func searchRange(nums []int, target int) []int {
	if len(nums) == 0 {
		return []int{-1, -1}
	}
	first := findFirst(nums, target)
	last := findLast(nums, target)
	return []int{first, last}
}

func findLast(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right-left)/2
		if nums[mid] <= target {
			// 等于时，有可能后边的元素仍然还是 target
			// 因为要寻找最后一个出现的元素，所以还需要向右查找
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	// 这里需要额外判断是否会越界，以及是否会等于 target
	if right < 0 || nums[right] != target {
		return -1
	}
	return right
}

func findFirst(nums []int, target int) int {
	left, right := 0, len(nums)-1
	for left <= right {
		mid := left + (right-left)/2
		if nums[mid] >= target {
			// 等于时，有可能前面仍然是 target
			// 因为要寻找第一个出现的元素，所以需要向左查找
			right = mid - 1
		} else {
			left = mid + 1
		}
	}
	// 这里需要额外判断是否会越界，以及是否会等于 target
	if left >= len(nums) || nums[left] != target {
		return -1
	}
	return left
}

```

## Java

第一个出现：

```java
public int findFirst(int[] nums, int target) {
	int left = 0, right = nums.length;
	while (left < right) {
		int mid = left + ((right - left) >> 1);
		if (nums[mid] >= target) {
			right = mid;
		} else {
			left = mid + 1;
		}
	}
	if (left >= nums.length || nums[left] != target) {
		return -1;
	}
	return left;
}
```

最后一个出现：

```java
public int findLast(int[] nums, int target) {
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    if (left - 1 < 0 || nums[left - 1] != target) {
        return -1;
    }
    return left - 1;
}
```

两次调用该方法即可。