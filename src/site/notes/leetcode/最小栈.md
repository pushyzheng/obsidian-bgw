---
{"dg-publish":true,"dg-permalink":"最小栈","permalink":"/最小栈/","title":"最小栈","tags":["栈"]}
---


#算法 

创建内部栈，**每一个元素存储两个值**：
1. *val*：当前元素的值；
2. *min*：迄今为止遇到的最小值。

这样能保证栈顶的元素其 min 值，就是**这个栈的所有元素的最小值**。

## Go

```go
type node struct {
    val int
    min int
}

type MinStack struct {
    st []*node
}

func Constructor() MinStack {
    return MinStack{st: make([]*node, 0, 10)}    
}

func (this *MinStack) Push(val int) {
    var minVal int
    if len(this.st) > 0 {
        topNode := this.st[len(this.st) - 1]
        minVal = topNode.min
    } else {
        minVal = math.MaxInt
    }
    this.st = append(this.st, &node{val, min(val, minVal)})
}

func (this *MinStack) Pop()  {
    if len(this.st) == 0 {
        return
    }
    this.st = this.st[:len(this.st) - 1]
}

func (this *MinStack) Top() int {
    if len(this.st) == 0 {
        return -1
    }
    topNode:=this.st[len(this.st)- 1]
    return topNode.val
}

func (this *MinStack) GetMin() int {
    topNode := this.st[len(this.st) - 1]
    return topNode.min
}
```

## Java

```java
class MinStack {
    
    Deque<Node> stack;
    
    public MinStack() {
        stack = new LinkedList<>();
    }
    
    public void push(int val) {
        if(stack.isEmpty()) {
            stack.push(new Node(val, val));
        } else {
            stack.push(new Node(val, Math.min(stack.peek().min, val)));
        }
    }
    
    public void pop() {
        stack.pop();
    }
    
    public int top() {
        return stack.peek().val;
    }
    
    public int getMin() {
        return stack.peek().min;
    }
    
    static class Node {
        
        int val;
        int min;
        
        Node(int val, int min) {
            this.val=val;
            this.min=min;
        }
    }
}
```