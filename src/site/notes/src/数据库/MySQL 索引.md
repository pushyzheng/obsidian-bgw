---
{"dg-publish":true,"dg-permalink":"MySQL 索引","permalink":"/MySQL 索引/"}
---


#数据库 #MySQL 

## MySQL 中都有哪些索引？

1. 物理维度划分
	- ==聚簇索引==（主键索引、一级索引）
		- [[src/数据库/B+树\|B+树]]的叶结点存储的**真实行数据**，一张表**只能有一个**
		- 数据在磁盘的排列顺序与**主键**索引的顺序一致
	- ==非聚簇索引==（辅助索引、二级索引）
		- [[src/数据库/B+树\|B+树]]叶节点存储的是**主键 ID**，一张表可以有多个
		- **回表**操作：通过主键索引查找完整行数据，有额外访问开销
2. 字段特性划分
	- ==主键索引==：建立在**主键**字段上的索引，一张表最多只有一个
	- ==唯一索引==：建立在 **UNIQUE** 字段上的索引，可以有多个
	- ==普通索引==：以普通字段建立的索引
	- ==前缀索引==：以字符串的**前几个字节**作为索引，为了减少索引占用的存储空间，提升查询效率
3. 索引列的**个数**
	- ==单列索引==：单列
	- ==联合索引==：通过将**多个**字段组合成一个索引

## B-树和 B+ 树的数据结构有什么区别？

1. ==[[src/数据库/B-树\|B-树]]==
	- 平衡的 N 叉树，通过每个结点存储更多数据，相对于二叉树**更加扁平**（树高更低）
	- **每层结点**都会存储数据
	- 每层结点存放的键比较少，导致树的**高度较大**
2. ==[[src/数据库/B+树\|B+树]]==
	- 是在[[src/数据库/B-树\|B-树]]基础上的变形，更加**扁平**
	- 每层的元素**不保存数据**，只用来索引（指向下一层的指针）
	- 叶子结点存储真实的数据，并以**双端链表**相连接，便于前后查找、范围查找、排序

## MySQL 索引底层结构为什么使用 B+树?

三个方向：
1. 为什么不使用常见的哈希表、有序列表呢？
	- 哈希表：MySQL 存在**复杂的查询**和**排序**操作
	- 有序列表：更新效率低
2. 为什么不使用二叉树？
	- 二叉树的**高度不平衡**，增大硬盘的随机 I/O 次数
3. 为什么不使用 B-树呢？
	- 树的高度较高，会有更多磁盘 I/O，查询**性能不稳定**
	- 由于数据可能在**中间**节点，不利于范围扫描
4. ==为什么使用 B+树？==
	- 内存页使用率更高：内部节点包含更多索引
	- 访问叶子结点**顺序遍历**效率高，适合**范围查询**

## 索引设计的原则

1. 原则**区分度高**的字段作为索引，降低重复率
2. 尽量使用**短索引**，减少索引的空间占用，长字段可以使用前缀索引
3. 利用[[src/数据库/最左匹配原则\|最左匹配原则]]

## 有什么优化索引的方法？

1. ==前缀索引优化==
2. ==覆盖索引优化==
	- 设计合理的覆盖索引，[[src/数据库/MySQL 回表#如何避免回表操作？\|不需要执行回表操作]]，减少大量的 I/O 操作
3. ==主键索引最好是自增的==
	- 聚簇索引下叶子节点数据是按主键顺序存放
	- 插入新数据时，是追加的方式，无需移动已有的数据，效率高
	- 如果不是自增，插入数据可能导致**页分裂**，造成大量的内存碎片
4. ==索引最好设置为 NOT NULL==
5. [[src/数据库/MySQL 索引#索引失效的情况有哪些?\|防止索引失效]]

## 索引失效的情况有哪些?

1. 不遵守[[src/数据库/最左匹配原则\|最左匹配原则]]的查询
2. 查询列是 varchar，但查询语句中使用 long 类型，导致出现**类型隐式转换**
	- 隐式类型转换还会出现查询结果不准确的问题
3. 对索引列**进行运算**或使用函数，如 `... WHERE id + 1 = 2;`
	- 因为索引保存的是索引字段的**原始值**，而不是经过函数计算后的值
4. 使用 **is not null** 查询，如：`... WHERE id IS NOT NULL;`
5. 使用 **NOT IN** 查询

[[src/数据库/索引失效的情况示例\|索引失效的情况示例]]

## 什么是索引下推？

从MySQL **5.6+** 版本开始引入的查询优化技术
- 将部分WHERE条件的过滤操作 **”下推“** 到[[src/数据库/MySQL 基础#MySQL 的服务架构\|存储引擎层]]的索引扫描过程
	- 而不是先根据索引找到行，再由MySQL服务层过滤
- 减少**回表次数**，从而显著提升查询效率

## 哪些字段使用使用索引？哪些场景不需要创建索引？

1. ==适用索引==
	- 字段有**唯一性**限制
	- 经常用于 **where** 查询条件的字段
	- 经常用于 **group by** 和 **order by** 字段
2. ==不需要创建索引==
	- 字段存在大量**重复**数据
	- 表**数据太少**：全盘扫描可能更快，不需要额外的索引维护成本
	- **经常更新**的字段：更新数据重建索引

## MySQL 的慢查询优化思路？

1. 开启并收集**慢查询日志**，定位慢查询 SQL
2. 用 *explain* 语句分析 SQL，特别关注两个字段
	- type: 避免出现 **ALL**（全表扫描）
	- extra：避免出现 Using temporary（使用临时表，**group by** 没有索引）和 Using filesort（使用文件排序，**order by** 没有索引）
3. 优化 SQL 语句
	- 避免复杂的子查询，用 join 来代替
	- 合理设计索引：[[src/数据库/最左匹配原则\|最左匹配原则]]

## 大数据量级下使用 LIMIT N,M 会出现什么问题？

会出现**深度翻页**问题：
1. 问题
	- 因为 `LIMIT N, M` 相当于 `LIMIT M OFFSET N`
	- 会先扫描 M + N 行，再丢弃前 N 行，取最后的 M 行，**效率低下**
2. 解决办法
	- 使用自记录的**偏移量**（ID）来走索引查询
	- 例如：`WHERE id > 3000000 LIMIT 100`