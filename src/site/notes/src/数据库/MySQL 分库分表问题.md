---
{"dg-publish":true,"dg-permalink":"MySQL 分库分表问题","permalink":"/MySQL 分库分表问题/"}
---


#数据库 #MySQL 

## 为什么要分库分表？

1. 为什么分库：
	- **单机数据库性能瓶颈**，连接数、吞吐量有限
	- 避免**边缘业务**影响到核心业务
2. 为什么分表：
	- **数据量大**的表查询性能降低（B+ 树的高度增大，I/O 次数越多，查询越慢）
	- **大字段**的拆分

## 怎么进行分表？

1. **垂直分表**
	- 将**大字段**或**使用频率较小**的字段拆分成单独的表，需要使用时再查询
	- 避免出现「跨页」的问题
2. **水平分表**
	- 基于**行数据**进行拆分，减少单表的记录数量
	- 利用 Hash 路由到指定表中
	- 避免查询的 I/O 次数太多，影响性能

## 分库分表会带来那些问题？

1. 分库
	- **事务**：使用分布式事务
	- **连表 JOIN**：不同库之间无法使用 JOIN 操作，可在代码先后查询操作
2. 分表
	- **排序、分页、count** 等操作：由业务代码或中间件来完成
	- **路由问题**

## 路由算法有哪些？

| Name      | 优点         | 缺点         |
| --------- | ------------ | ------------ |
| Hash 路由 | 数据分布均匀 | 但扩展麻烦   |
| 范围路由  | 容易扩展     | 但分布不均匀 |
| 路由表    | 比较灵活     | 多一次查询路由表的 I/O<br>但可以做缓存             |

**全局主键**：
- 修改自增的步调：
- UUID：不适合做主键，会导致严重的页分裂，性能较差
- 分布式 ID：Snowflake

## 分布分表的框架或者中间件？

1. SphereSphere
	- Sharding-JDBC：客户端实现（Java 同构）
		- 分库分表
		- 读写分离
		- 分布式主键
	- Sharding-Proxy：代理实现，对业务透明（异构语言）
		- 提供分布式事务
	- Sharding-Sidecar：云原生数据库代理
