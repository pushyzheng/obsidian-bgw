---
{"dg-publish":true,"dg-permalink":"MySQL 事务","permalink":"/MySQL 事务/"}
---


#数据库 #MySQL 

## 事务的概念是什么？

1. [四大特性](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Fconcept%2F%E4%BA%8B%E5%8A%A1)：
	- 原子性
	- 一致性
	- 隔离性
	- 持久性
2. [可能导致的错误](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FMySQL%20%E4%BA%8B%E5%8A%A1%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF)：
	- 脏读：读取到其他事务还**未提交的修改**数据
	- 不可重复读：一个事务中两次查询同一记录，返回**不同**数据
	- 幻读
		- 事务 A 读取某个**范围**记录时，之后事务 B 在该范围修改
		- 事务 A 再次读取该范围时，出现幻行

## 请你谈谈 MySQL 事务隔离级别，MySQL 的默认隔离级别是什么?

1. [四种隔离级别](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FMySQL%20%E4%BA%8B%E5%8A%A1)：
	- 未提交读
		- **未提交**的修改，可以被其他事务看到
		- 同时会出现脏读、幻读的情况
	- 读已提交
		- 只有**已提交**的修改，才可以被其他事务看到
		- 不会出现脏读
	- 可重复读
		- 一个事务执行过程看到的数据和开始时**始终相同**
		- 不会脏读和不可重复读，但仍然会有幻读出现
	- 串行化
		- 加锁执行
2. 数据库的默认隔离级别：
	- *MySQL* ：**可重复读**
	- *Oracle* ：已提交读
3. 实现原理
	- 未提交读：没有任何限制
	- 已提交读：**每次 select** 都生成一个快照读
	- 可重复读
		- 事务**开始到结束**都使用同一个视图
		- [ Next Key 锁（行锁 + 间隙锁）](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FMySQL%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84%EF%BC%9F)
	- 串行化：加锁单线程执行

## 事务的实现原理？

事务是基于 redo log 、 undo log 以及 MVCC（保证隔离性）实现的：
1. 原子性、持久性
	- [redo log](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FMySQL%20%E6%97%A5%E5%BF%97)  的**两阶段提交**
2. 一致性
	- undo log 实现回滚
3. 隔离性
	- MVCC 机制实现读已提交、可重复读隔离级别

## MVCC 是什么? 它的底层原理是什么?

1. 定义
	- MVCC 即**多版本**并发控制
	- 用于解决读写冲突的**无锁**并发控制
2. 实现原理
	- 事务的**版本号**
		- 数据会有多个版本，每个版本都有一个唯一的时间戳
		- 事务 ID 记录在数据页中的 *DB_TRX_ID* 隐式字段中
		- 行记录快照存储在 undo log 中
	- **读视图**
		- 事务开始后的所有读操作，都使用**同一个**的读视图
3. 优点
	- 提高了数据库**并发读写**的性能
	- 解决脏读、幻读（快照读）、不可重复读等**事务隔离问题**
	- 是一种乐观锁，可**降低**出现死锁的概率
	
## 6. 长事务会有那些问题？

1. 回滚段不会被清除
	- 由于 MVCC 的机制，长事务会保留**很老的**事务视图
	- 会占用大量的**存储空间**
2. 占用锁资源
	- 长事务会一直占用**锁资源**，从而影响系统性能

## 参考资料

> [!QUOTE] 
> [面试八股文——MySQL篇](https://zhuanlan.zhihu.com/p/422357431)