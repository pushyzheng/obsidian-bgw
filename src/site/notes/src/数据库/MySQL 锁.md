---
{"dg-publish":true,"dg-permalink":"MySQL 锁","permalink":"/MySQL 锁/"}
---


#数据库 #MySQL 

## MySQL 中有哪些锁？

1. ==全局锁==
	- 全库变为 *readonly* 状态
	- 用途：全局逻辑备份
2. ==表级锁==
	- 表锁
		- 行锁未出现之前解决并发问题
	- 意向锁
		- 提高判断**是否有行记录被加锁**的效率
		- 使得行锁和表锁共存
	- MDL 锁（不需要显式调用）
		- 保证当用户对表执行 CRUD 操作时，防止其他线程对这个**表结构**做了变更
			- 对一张表进行 CRUD（DML），加MDL**读**锁
			- 执行结构变更（DDL）时，加MDL**写**锁
3. ==行级锁==
	- [[src/数据库/记录锁\|记录锁]]： 降低**并发控制的粒度**
	- [[src/数据库/间隙锁\|间隙锁 Gap Lock]]： 锁住一个**范围**，解决幻读问题
	- [[src/数据库/Next-Key 锁\|Next-Key 锁]]：[[src/数据库/记录锁\|Record Lock]] + [[src/数据库/间隙锁\|Gap Lock]]

## 什么是快照读和当前读？

- **快照读**：读取的是快照版本（MVVC），如 `SELECT`
- **当前读**：读取的是最新版本，如 `UPDATE`、`SELECT … FOR UPDATE`、

当前读由于读取的最新数据，是有可能出现幻读的情况的。

## MVVC 多版本并发控制机制

MVVC(*Multi-Version Concurrency Control*)是**多版本并发控制**机制。

- 通过维护数据的**多个版本**来实现高并发和事务隔离的机制
- 用于解决读写冲突的**无锁**并发控制
- 多事务并发访问时，读写操作**不会相互阻塞**

核心原理：
- ==版本管理==
	- 每一行都会维护**多个版本**，每个版本都有一个唯一的时间戳
	- 事务执行期间只能看到符合条件的**同一版本**
- ==读方式==
	- 快照读：读取的是事务**开始时**的快照版本，不加锁，非阻塞
	- 当前读：读取的是最新版本，**并加锁**，阻止其他事务修改

## MVVC 解决了什么问题？

- ==性能==
	- 提高了数据库**并发读写**的性能
	- 是一种乐观锁，可**降低**出现死锁的概率
- ==事务隔离级别==
	- 脏读：事务只能看到**已提交**的版本
	- 避免不可重复读：快照读保证同一事务内**多次查询**结果一致
	- 减少幻读

## 什么是 MySQL 意向锁，解决了什么问题？

意向锁是 InnoDB 自动加的**表级锁**，用户无法显式操作

解决了：
1. 快速判断表里是否有**记录**被加锁
2. 实现了行锁和表锁的多粒度锁机制，使得表锁和行锁**可以共存**

## MySQL 是如何解决幻读的？

- 对于[[src/数据库/MySQL 锁#什么是快照读和当前读？\|快照读]]：通过 **MVVC** 机制 来实现
- 对于[[src/数据库/MySQL 锁#什么是快照读和当前读？\|当前读]]：通过[[src/数据库/Next-Key 锁\|Next-Key 锁]]来实现的
	- 假设对 a = 8 执行当前读，会加以下的锁：
		- 记录锁：锁住 a = 8 行的本身
		- [[src/数据库/间隙锁\|间隙锁]]：(5, 8) 区间所有的行
		- [[src/数据库/Next-Key 锁\|Next-Key 锁]]：(8, 11] 范围

MySQL 并没有**完全解决**幻读，如先快照读后**当前读**：
1. 事务 A 先执行 `id > 100` 的快照读
2. 事务 B 插入 `id = 200` 的记录
3. 事务 A 执行 `id > 100 for update` 的当前读（此时可以读取到其他事务提交的数据），导致与之前读取到的数据不一致

## 使用 MySQL 如何避免死锁？

1. 大事务化成小事务
2. 避免加表锁：尽量使用索引访问数据，这样可以加行锁