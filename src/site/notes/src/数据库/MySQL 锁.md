---
{"dg-publish":true,"dg-permalink":"MySQL 锁","permalink":"/MySQL 锁/"}
---


#数据库 #MySQL 

## MySQL 中有哪些锁？

1. **全局**锁
	- **全库**变为 *readonly* 状态
	- 用途：全局逻辑备份
2. **表级**锁
	- 表锁：行锁未出现之前解决并发问题
	- 意向锁
		- 提高判断**是否有行记录被加锁**的效率
		- 使得行锁和表锁共存
	- MDL 锁：
		- 防止 DML 和 DDL 的冲突
			- 执行 DDL （结构变更）时，加写锁
			- 执行 DML （CRUD）时，加读锁
3. **行级**锁
	- 记录锁（Record lock）： 降低**并发控制的粒度**
	- 间隙锁（Gap lock）： 锁住一个**范围**
	- [[src/数据库/MySQL 锁#Next Key 锁\|Next Key 锁]]：Record lock + Gap lock

## 什么是快照读和当前读？

- **快照读**：读取的是快照版本（MVVC），如 `SELECT`
- **当前读**：读取的是最新版本，如 `UPDATE`、`SELECT … FOR UPDATE`、

当前读由于读取的最新数据，是有可能出现幻读的情况的。

## MVVC 多版本并发控制机制

MVVC(*Multi-Version Concurrency Control*)是**多版本并发控制**机制。

- 通过维护数据的**多个版本**来实现高并发和事务隔离的机制
- 用于解决读写冲突的**无锁**并发控制
- 多事务并发访问时，读写操作**不会相互阻塞**

核心原理：
- 版本管理
	- 每一行都会维护多个版本，每个版本都有一个唯一的时间戳
	- 事务根据启动时间只能看到符合条件的版本
- 读方式
	- 快照读：读取的是事务**开始时**的快照版本，不加锁，非阻塞
	- 当前读：读取的是最新版本，**并加锁**，阻止其他事务修改

解决问题：
- 性能
	- 提高了数据库**并发读写**的性能
	- 是一种乐观锁，可**降低**出现死锁的概率
- 事务隔离级别
	- 脏读：事务只能看到**已提交**的版本
	- 避免不可重复读：快照读保证同一事务内**多次查询**结果一致
	- 减少幻读

## Next Key 锁

Next-Key Lock是“行锁（Record Lock）+间隙锁（Gap Lock）”的结合，可避免幻读
- 锁定某条记录本身以及它前面的间隙
- 既防止了对已有记录的修改，也阻止了其他事务在该记录前的间隙中插入新记录

```sql
select ...
WHERE age BETWEEN 20 AND 30 FOR UPDATE
```

## 什么是 MySQL 意向锁，解决了什么问题？

意向锁是 InnoDB 自动加的**表级锁**，用户无法显式操作

解决了：
1. 提高了是否可以加锁的**判断效率**
2. 实现了行锁和表锁的多粒度锁机制，使得表锁和行锁**可以共存**

## MySQL 是如何解决幻读的？

- 对于[[src/数据库/MySQL 锁#什么是快照读和当前读？\|快照读]]：通过 **MVVC** 机制 来实现
- 对于[[src/数据库/MySQL 锁#什么是快照读和当前读？\|当前读]]：通过[[src/数据库/MySQL 锁#Next Key 锁\|Next key lock]]来实现的
	- 假设对 a = 8 执行当前读，会加以下的锁：
		- 记录锁：锁住 a = 8 行的本身
		- 间隙锁：(5, 8) 区间所有的行
		- Next Key（间隙锁）：(8, 11] 范围
- MySQL **并没有完全解决**幻读，如**先快照读后当前读**：
	- 事务 A 先执行 `id > 100` 的快照读
	- 事务 B 插入 `id = 200` 的记录
	- 事务 A 执行 `id > 100 for update` 的当前读，与之前读取到的数据不一致

## 使用 MySQL 如何避免死锁？

1. 大事务化成小事务
2. 避免加表锁：尽量使用索引访问数据，这样可以加行锁