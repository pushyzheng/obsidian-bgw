---
{"dg-publish":true,"dg-permalink":"消息队列常见的问题","permalink":"/消息队列常见的问题/"}
---


#消息队列 #中间件 

## 为什么要用消息队列？（消息队列的应用场景？)

1. **业务解耦**：消息队列要解决的本质问题
	- 关心的是「**通知**」，而非「处理」
	- 例子：交易系统发送订单变更的消息，SOA 监听向代理商下单
2. **错峰和流控**（异步、削峰）
	- 解决上下游处理能力不匹配问题；
	- 暂存消息到 Broker，消费者按需消费；
	- 用于解决可以延迟的业务，做到快速返回；
	- 例子：后端服务写数据到 MySQL、短信系统发送短信（低延迟并不影响用户体验）。
3. **广播**：
	- 只需要关心是否成功投递到消息队列即可，**不用关心谁订阅**，减少开发和联调；
	- 例子：变价通知、集群所有主机本地缓存刷新
4. **最终一致性**：
	- 使用**「记录」和「补偿」**的方式来达到最终一致性
	- 例子：向代理商下单失败，发送消息重试
5. **分布式事务**：
	- 如 RocketMQ 的半消息机制实现简单的分布式事务

## 消息队列有哪些缺点？

1. 系统**可用性降低**：引入了外部依赖的第三方分布式组件，需要保证高可用；
2. 系统**复杂度提高**：需要考虑引入消息队列依赖带来的一系列问题：
	- 消费**幂等**（重复消费）问题；
	- 消息**丢失**问题
	- 消息**顺序性**问题
3. **一致性问题**

## 消息队列模型都有哪些？

1. 队列模型
	- 有 *RabbitMQ*
	- 每个消费者只能读取队列**一部分**消息
2. 发布 - 订阅模型
	- 有 *RocketMQ* 和 *Kafka*
	- 每个消费者能读取队列的**全量**消息

## 各种消息队列产品的比较？

参考：[消息队列技术选型](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B)

1. RabbitMQ：性能略差，Erlang 语言不适合二次开发
2. RocketMQ：高吞吐、高性能、支持分布式事务
3. Kafka：高吞吐、高性能；但延迟性高、不易扩展
4. Pulsar：存储和计算分离、易于横向扩展

## 如何保证消息不丢失？

消息的丢失发生阶段，及解决方案：
1. Producer **投递**阶段
	- 本地持久化重试
	- ACK 机制来保证 Broker 接收到消息
2. Broker **存储**阶段
	- 落盘后才给 Producer 发送 ACK
3. Consumer **消费**阶段
	- ACK + 重试补偿机制，保证 Consumer 成功消费；

## 如何保证消息不被重复消费？（如何保证消息消费的幂等性？）

消息的三种服务质量：
1. 至多一次：有丢消息的可能
2. 至少一次（大部分情况）：有重复消息的可能
3. 正好一次：比较理想的情况，但实现较难

MQ 很难同时保证消息可靠和消息重复，大多都选择保证消息可靠，容忍少量重复。所以由业务来保证接口的幂等性。

在 QMQ 的实现方式支持拓展 *AbstractIdempotentChecker* 幂等处理器，来解决重复消费的问题。默认的实现有：
- **JDBC 转储**：每次消费前判断之前是否消费过，但有丢消息的风险
- **添加事务**：让判断逻辑和执行业务在一个 MySQL 事务，保证原子性

## 如何保证消息消费的顺序性？

由于 Kafka、RocketMQ 只能保证在**同一个 partition** 中的消息是有序的，以 Kafka 为例：
1. 一个主题只分一个 partition，只由一个 consumer 单线程消费
	- 优点：实现比较简单，可保证全局有序
	- 缺点：吞吐量太低
2. 区分 Key（可以是订单号、用户 ID 等唯一标识字段）
	- 使用多个 partition，相同 Key 的消息路由到同一个 partition，consumer 进行单线程消费
3. 多线程消费
	- 在方案 2 的基础上，如果要多线程消费。那么需要定义内存 Queue，再通过 Key 进行分发，一个线程只消费一个内存 queue。

## 基于 MQ 的分布式事务实现

参考：
<div class="transclusion internal-embed is-loaded"><a class="markdown-embed-link" href="/分布式/#" aria-label="Open link"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a><div class="markdown-embed">

<div class="markdown-embed-title">

# 分布式事务

</div>


## 如何保证接口的幂等性？

1. [幂等](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Fconcept%2F%E5%B9%82%E7%AD%89%E6%80%A7) 概念
	- 指一个接口，多次发起同一个请求，影响的结果都相同
2. 实现方案：
	- **唯一键约束**：通过 MySQL 唯一约束来保证
	- **请求唯一标识**：如相同订单只能支付一次
	- **去重**（日志表）：消费前，判断重复；消费后，记录


</div></div>


## 如何保证消息队列的高可用？

