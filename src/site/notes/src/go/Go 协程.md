---
{"dg-publish":true,"dg-permalink":"Go 协程","permalink":"/Go 协程/"}
---


#Go 

## go 协程（Goroutine）与传统线程有什么区别？

1. 协程是[[src/计算机基础/操作系统#线程都有哪些实现？\|轻量级线程]]，初始栈只有几 KB，线程是 MB 级别
2. 协程是**用户态**的，由 Go 的调度器把它们映射到少量的内核线程上跑，切换开销小，更适合解决高并发场景

## go 协程的底层设计原理？

1. 使用与 CPU 数量相等的线程减少线程频繁切换的内存开销
2. 使用 [[src/计算机基础/操作系统#如何设计一个协程？\|设计协程调度策略中的 M:N 调度]]
	- 内核负责对这 N 个操作系统线程进行调度
	- N 个系统线程，通过 goroutine 调度器对这 M 个协程进行调度和运行

## GMP 模型

G-M-P分别代表：
- G - Goroutine
	- 轻量级协程，抽象为**任务**，是参与调度与执行的**最小单位**
	- 理论上没有上限
- M - Machine
	- **系统级**线程，真正干活的
	- 可通过 runtime.SetMaxThreads 设置 M 的最大数量
- P - Processor
	- 调度器的上下文：管理**任务队列**、栈信息等，最多可存放256个G
	- 可通过 GOMAXPROCS 设置，意味着程序执行时只有多少个 goroutine 在**同时执行**

![Pasted image 20250703193137.png](/img/user/attachments/images/Pasted%20image%2020250703193137.png)

## GMP 模型的调度流程

1. 线程 M 执行任务先与 P 关联，并从 **P 的本地队列**（LRQ）获取 G
2. 如果本地队列为空，则从**全局队列**（GRQ）取一批放到本地队列
3. 如果全局队列也空，则从**其他的 P** 本地队列中“偷”一半到自己 P 的本地队列
4. 执行 G，G 执行之后，会继续从 P 获取，依次循环