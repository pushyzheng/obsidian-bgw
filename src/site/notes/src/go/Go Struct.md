---
{"dg-publish":true,"dg-permalink":"Go Struct","permalink":"/Go Struct/"}
---


## 如何计算结构体占用的空间?

可以通过 **unsafe.Sizeof** 来计算出一个数据类型实例需要占用的字节数。

例如对于：

```go
type Flag struct {
    num1 int16
    num2 int32
}

func main() {
    fmt.Println(unsafe.Sizeof(Flag{}))
}
```

大小为：4（int32）+ 2 （int16）+ 2(**内存对齐**) = 8

> [!NOTE] 
> 因此，一个结构体实例所占据的空间 = 各字段占据空间之和 + 内存对齐的空间大小


## 结构体字段为何要内存对齐？

CPU 访问内存时，并不是逐个字节访问，而是**以字长**为单位访问，为了减少 CPU 访问内存的次数。

如下图，如果没有进行对齐，那么读取变量 b 则需要读取两次：

![Pasted image 20250717203653.png](/img/user/attachments/images/Pasted%20image%2020250717203653.png)

同时内存对齐后，每次内存访问变量的操作也是原子的，对实现**变量的原子性操作**也是有好处的。

## 空结构体struct{} 的空间占用情况和用途？

具有以下两个核心特点:
1. 空间占用**为零**：由于不包含任何字段，所以编译器会优化为 0 字节，不占用任何内存空间
2. 可被用作占位符或信号标记
	- 如用 `map[key]struct{}` 来表示集合，这样 value 不占用内存
	- 用于协程间无数据传递的通知

## 结构体是否可以进行比较？

结构体是否可以比较取决于字段中是否包含**全部**可以比较的字段：

1. 可比较：int、float、string
2. 不可以比较：func、chan、map[string]string 等包含接口类型的字段

只有当所有字段都相等时，结构体才被认为相等。[[src/go/Go 结构体比较示例\|Go 结构体比较示例]]

## 结构体的指针接收者和值接收者有什么区别？

- 指针接收者（`func (p *Type) Method()`）
	- 方法中可以修改结构体字段的值
	- 对于结构体较大，可**避免拷贝开销**
	- 方法实现接口时，只有指针类型变量能赋值给接口
- 值接收者（`func (p Type) Method()`）
	- 操作的是**结构体副本**，修改不会影响原对象
	- 方法实现接口时，值类型和指针类型变量均可赋值给接口