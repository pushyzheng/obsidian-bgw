---
{"dg-publish":true,"dg-permalink":"Go-String","permalink":"/Go-String/"}
---


## string 的底层数据结构？

> [!TIP] Tips
> 字符串没有容量（cap）字段，len 方法返回的是字节的长度，而非字符的长度

底层数据结构是一个**只读**的字节数组的描述符，包含两个核心字段：
1. 指向底层字节数组的指针（不可变的、只读的）
2. 字符串长度（**字节**的长度）

## 如何高效地拼接字符串？

1. **大量**字符串拼接优先使用 `strings.Builder`，能自动扩容且减少内存拷贝
2. 如果能**准确预估**拼接后字符串长度，使用预分配 `[]byte` 切片并 append，最后转换为字符串，性能最优的方案
3. `bytes.Buffer` 性能低于 `strings.Builder`

## string 转换为byte切片会发生内存拷贝吗?

结论：Go 会新分配一块内存，并将字符串中的数据复制到这块内存中，因此**存在一次**内存拷贝操作

原因：
- string 是不可变的字节序列，[]byte 是可变的切片，底层结构不同
- 转换时必须复制数据以保证字符串的**不可变性**

## rune 类型的定义？

rune 类型本质上是**int32**的别名，用于表示Unicode码点，支持全球范围内的字符。

使用场景：
- 使用 **range** 遍历字符串时，可以得到每个字符的 rune 值
- 处理国际化文本、**多语言字符**，能准确识别每个字符，避免乱码、字符截断问题

```go
func main() {
	s := "Hello, 世界"
	for _, rune := range s {
		fmt.Printf("%c, ", rune)
	}
}

// output
// H, e, l, l, o, ,,  , 世, 界, 
```

## rune 和 byte 与 string 的区别

| 类型   | 底层类型 | 存储大小              | 表示内容    |
|:------ |:-------- |:--------------------- | --- |
| byte   | uint8    | 1字节                 |  单个字节，ASCII 字符   |
| rune   | int32    | 4字节                 |  一个 Unicode 码点（字符）   |
| string | 字节切片 | 每个字符占1~4字节不等 |  UTF-8 编码的字节序列   |

使用场景：
- byte：适合处理 ASCII 字符和**二进制**数据
- rune：适合对**多语言**、表情字符串按单个字符操作
- string：不可变的 UTF-8 编码字节序列，len() 函数返回的是**字节长度**而非字符数