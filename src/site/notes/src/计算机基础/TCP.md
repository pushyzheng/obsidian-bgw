---
{"dg-publish":true,"dg-permalink":"TCP","permalink":"/TCP/"}
---


#计算机网络 

## 请详细介绍下 TCP 的三次握手机制吗？为什么要三次握手?

- 为什么要有握手？
	- 保证可靠数据的传输，即通信双方能正常地收发
	- 最**主要的目的**是：交换彼此的**初始序列号**（ISN）
- 为什么是三次？
	- 两次：B 不能确定 A 已经成功接收到了自己的初始序列号
	- 四次：第四次可以省略

## 三次握手的流程？

[TCP 的三次握手](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FTCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)过程：
1. 请求连接
	- 发送 SYN = 1 的连接请求报文
	- 传递客户端随机选择的**初始序列号**（client_isn）
2. 连接确认
	- 发送 SYN = 1 的连接确认报文
	- 传递服务端随机选择的初始序列号（server_isn）
	- 传递 **client_isn + 1** 的 ACK 报文
	- 服务端开始为 TCP 连接**分配资源**（缓存和变量）
3. 客户再次确认
	- 发送 SYN = 0 的报文，表示连接建立
	- 传递 **server_isn + 1** 的 ACK 报文
	- 客户端开始为 TCP 连接**分配资源**（缓存和变量）

## TCP 的四次挥手机制？

[TCP 的四次挥手](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FTCP%20%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)的过程：

1. 客户端**主动断开**连接
	- 发送 FIN = 1 的报文
	- 表示不再发送数据
2. 服务端回传表示已经收到
	- 回传给发送方一个 ACK，表示已经知道断开请求了
	- 继续发送未完成的数据
3. 服务端**主动断开**连接
	- 发送 FIN = 1 的报文
	- 数据已发送完毕
4. 客户端回传 ACK
	- 发送 ACK 进行确认
	- 进入**超时等待**（TIME-WAIT）

## TCP 拥塞控制和流量控制的异同点？

1. 相同点：
	- 他们的实现原理都有**滑动窗口**（拥塞窗口）
2. 不同点：
	- [拥塞控制](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FTCP%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)是为了降低**发送方**的速率
	- [流量控制](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=todo%2FTCP%20%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)主要是因为**接收能力**下降
	
## TCP 中常见的拥塞控制算法有哪些？

这里的值指的是 cwnd 拥塞滑动窗口的大小。

1. 慢启动
	- 从初始值开始，**指数**速率增长到阈值
	- 目的：进行探测
2. 拥塞避免
	- 从慢启动阈值开始，以**线性**速率进行增长
	- 目的：降低速率，避免出现拥塞
3. 快速恢复
	- 收到 3 个重复 ACK 时（少许延迟），窗口大小设置为阈值的一半，并重新进入拥塞避免
	- 目的：网络出现少量拥塞，**减轻负载**

## 基于 TCP 和 UDP 的应用层协议都有那些？

- TCP：
	- HTTP：超文本传输协议；
	- FTP：文件传输协议；
	- SMTP：简单邮件传输协议；
	- TELNET：
	- SSH
- UDP：
	- DNS：域名服务
	- TFTP：
	- SNMP：
	- NTP：网络时间协议