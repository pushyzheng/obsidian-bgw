---
{"dg-publish":true,"dg-permalink":"TCP","permalink":"/TCP/"}
---


#计算机网络 

## 请详细介绍下 TCP 的三次握手机制吗？为什么要三次握手?

- 为什么要有握手？
	- 保证可靠数据的传输，即通信双方能正常地收发
	- 最**主要的目的**是：交换彼此的**初始序列号**（ISN）
- 为什么是三次？
	- 两次：B 不能确定 A 已经成功接收到了自己的初始序列号
	- 四次：第四次可以省略

## 三次握手的流程？

[TCP 的三次握手](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FTCP%20%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)过程：
1. 请求连接
	- 发送 SYN = 1 的连接请求报文
	- 传递客户端随机选择的**初始序列号**（client_isn）
2. 连接确认
	- 发送 SYN = 1 的连接确认报文
	- 传递服务端随机选择的初始序列号（server_isn）
	- 传递 **client_isn + 1** 的 ACK 报文
	- 服务端开始为 TCP 连接**分配资源**（缓存和变量）
3. 客户再次确认
	- 发送 SYN = 0 的报文，表示连接建立
	- 传递 **server_isn + 1** 的 ACK 报文
	- 客户端开始为 TCP 连接**分配资源**（缓存和变量）

## TCP 的四次挥手机制？

[TCP 的四次挥手](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2FTCP%20%E7%9A%84%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)的过程：

1. 客户端**主动断开**连接
	- 发送 FIN = 1 的报文
	- 表示不再发送数据
2. 服务端回传表示已经收到
	- 回传给发送方一个 ACK，表示已经知道断开请求了
	- 继续发送未完成的数据
3. 服务端**主动断开**连接
	- 发送 FIN = 1 的报文
	- 数据已发送完毕
4. 客户端回传 ACK
	- 发送 ACK 进行确认
	- 进入**超时等待**（TIME-WAIT）

## TCP 拥塞控制和流量控制的异同点？

1. 相同点：
	- 他们的实现原理都有**滑动窗口**（拥塞窗口）
2. 不同点：
	- [[src/计算机基础/拥塞机制\|拥塞机制]]：是为了降低**发送方**的速率
	- 流量控制：主要是因为**接收能力**下降
	
## TCP 中常见的拥塞控制算法有哪些？

[[src/计算机基础/拥塞机制\|拥塞机制]]

## 基于 TCP 和 UDP 的应用层协议都有那些？

- TCP：
	- HTTP：超文本传输协议；
	- FTP：文件传输协议；
	- SMTP：简单邮件传输协议；
	- TELNET：
	- SSH
- UDP：
	- DNS：域名服务
	- TFTP：
	- SNMP：
	- NTP：网络时间协议

## 怎么解决TCP网络传输「粘包」问题？

1. 什么是粘包？
	- 发送方连续发送的**多个**数据包，在接收方的缓冲区中被**合并成一个**连续的字节流
	- 应用层无法区分数据包边界，造成数据解析困难
2. 产生的原因？
	- TCP是**面向字节流**的协议，没有消息边界的概念
	- 应用层协议设计不当，没有进行字节流的解析
3. 如何解决？
	- **固定包长度**：每个包长度固定，接受方按**固定长度**读取数据
	- **特殊分隔符**：在每个包末尾加上特殊字符（如 \n），接收方根据分隔符进行**拆包**
	- **包头加长度字段**