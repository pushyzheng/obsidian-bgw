---
{"dg-publish":true,"dg-permalink":"进程与线程","permalink":"/进程与线程/"}
---


## 进程都有哪些状态？

1. ==创建状态==
	- 进程正在被**创建时**的状态
2. ==运行状态==
	- 该时刻**占用** CPU
3. ==就绪状态==
	- 可运行，**等待** CPU 的控制权
	- 由于其他进程处于运行状态而暂时停止运行
4. ==阻塞状态==
	- 等待某一事件(如请求I/O事件)的发生而暂时停止运行
	- 此时即使 CPU 给它控制权，也无法运行
5. ==结束状态==
	- 进程正在从系统**消失**时的状态

## 进程的 PCB 具体包含什么信息呢？

PCB(process control block)是进程存在的**唯一标识**，这意味着一个进程的存在，包含：
1. ==进程描述信息==
	- 进程标识符
	- 用户标识符
2. ==进程控制和管理信息==
	- 进程当前**状态**
	- 进程**优先级**
3. ==资源分配清单==
	- 内存地址空间
	- 所打开文件的列表和所使用的 I/O 设备信息
4. ==CPU 相关信息==（执行上下文）
	- 各个寄存器的值

## 进程上下文切换的过程？

这个换出/换入全过程就是进程上下文切换:
1. 把当前进程的全部**运行现场**（用户态+内核态的寄存器、虚拟内存、栈等）保存到 **PCB**
2. 把下一个进程的 PCB 中的现场**恢复**到 CPU

五大触发场景:
1. 时间片用完
2. 等待资源就绪（内存、I/O）
3. 主动休眠（sleep/pause）
4. 高优先级进程抢占
5. 硬件中断

## 进程通信有几种方式？

1. ==匿名管道和命名管道==
	- 匿名管道: 通信范围是存在**父子关系**的进程，因为匿名管道没有实体(管道文件)
	- 命名管道：可以在**不相关**的进程间也能相互通信，会创建设备文件
2. ==信号==
	- 异步通信机制: 通知接收线程某个事件已经发生
3. ==消息队列==
	- 保存在内核中的**消息链表**，线程分别从队列中写入和读取消息
4. ==共享内存==
	- 多个线程同时访问**一块内存空间**，但需要同步操作，如互斥量
5. ==信号量==
	- 整型的计数器，主要用于实现进程间的**互斥与同步**，包含 P/V 操作
	- 不是用于缓存进程间通信的数据
6. ==套接字==
	- 可用于网络中不同机器&同机器之间的进程间通信

## 什么情况下会使用多进程？

1. 多进程可以实现**资源隔离**，不需要考虑太多内存锁之类
2. 需要利用**多核**，单线程吃不满 CPU
3. 缺点：无法和多线程一样，共享内存数据

## 为什么使用线程？

1. 多进程的弊端：进程之间无法方便地通信（共享数据）
2. 维护进程的系统**开销较大**：分配资源和 PCB 等
3. 线程：相互之间可以并发运行且**共享相同**的地址空间

## 进程和线程的区别？

- ==进程==
	- **资源分配**的基本单位
	- 是正在运行的**程序**的抽象
- ==线程==
	- **系统调度**的最小单元
	- 一个进程中可以有多个线程，它们**共享进程资源**(代码段、数据段、打开的文件等)
- ==区别==
	1. 线程不拥有资源
	2. 线程的切换不会引起进程切换
	3. 进程系统开销大于线程
	4. 进程通信需要借助 IPC

## 线程的优缺点？

1. ==优点==
	- 一个进程可以同时存在多个线程
	- 各个线程可以**并发**执行
	- 各个线程可以**共享**地址空间和文件等资源
2. ==缺点==
	- 对于 C/C++ 语言来说，一个线程崩溃时会导致其所属进程的所有线程崩溃

## 线程都有哪些实现？

1. ==轻量级线程==
	- 在**内核**中来支持用户线程
	- 一个轻量级进程对应一个内核线程（1：1）
	- 线程调度会出发系统调用，**效率低**
2. ==[[src/计算机基础/用户线程\|用户线程]]==
	- 在**用户空间**实现的线程，不由内核管理，而是由用户态线程库来管理
	- **多个**用户线程对应一个内核线程（1：N，Java 采用的模式）
	- 优点：切换不需要系统调用，**效率很高**
	- 缺点：实现**复杂**、难度大
3. ==混合线程==（N：M）
	- 轻量级进程与用户线程的混合

## 如何设计一个协程？

1. 区别
	- 线程/进程是内核进行调度，有 CPU 时间片概念，进行**抢占式**调度
	- 协程对内核透明，需要由用户程序自己控制，进行**协作式**调度（主动转让控制权）
2. 调度策略
	- 1:1 调度（1 个协程绑定 1 个线程）
		- 优点：实现**简单**，协程的调度都由 CPU 完成
		- 缺点：上下文切换等同于线程切换，比较慢
	- N:1 调度（N 个协程绑定 1 个线程）
		- 优点：在用户态就可以完成切换，**轻量快速**
		- 缺点：某协程阻塞，会造成线程阻塞，从而本线程的其他协程也会被阻塞
	- M:N 调度（M 个协程绑定 N 个线程）
		- 优点：克服上面两个的缺点
		- 缺点：实现复杂