---
{"dg-publish":true,"dg-permalink":"Java 基础","permalink":"/Java 基础/"}
---


#Java #Java基础 

## 基本类型

| Name     | 所占比特                       | 
| -------- | ------------------------------ |
| byte     | 8                              |
| short    | 16                             |
| char     | 16                             |
| int      | 32                             |
| float    | 32                             |
| long     | 64                             |
| double   | 64                             |
| boolean  | 1                              |
| 引用类型 | 64 位平台上：8 位，32 位：4 位 |

数据范围计算：
- 对于 int 来说，第一位是标志位（正数为 0， 负数为 1），所以只有 31 位可以表示
- 最小值：`-2 ^ 31`
- 最大值：`-2 ^ 31 + 1`

## 什么是包装类型？以及拆箱和装箱？

Integer 是 int 基本类型的包装类型，会在编译期进行自动的拆箱和装箱（将基本数据类型和包装类型进行转换的过程，本质上是一种**语法糖**），即：
- ==装箱==
	- `Integer i = 10;`
	- 基本类型 -> 包装类型，调用 **valueOf** 方法
- ==拆箱==
	- `int n = i;`
	- 包装类型 -> 基本类型，调用 **intValue** 方法
- ==自动装拆箱==
	- 赋值时候
	- 方法调用：参数是 Integer 类型，但是传入了 int

## Integer 的缓存机制

1. Integer类内部实现了一个**静态缓存池**
2. 存储特定范围内（`[-128, 127]`）的整数值对应的Integer对象
3. valueOf 会先从内部的缓存中获取数据，并不会每次都生成新的对象实例

## Java 是值传递还是引用传递？

Java 不论是基本类型还是引用类型，都是**值传递**，且只有值传递。

引用类型的值存储的是：**对象在堆中的地址**。

![Pasted image 20220328122200.png|400](/img/user/attachments/images/Pasted%20image%2020220328122200.png)

## float 和 double 精度丢失问题？如何去避免？

1. 精度丢失原因
	- float 和 double 都是浮点运算
	- 小数点转二进制**丢失精度**
2. 如何避免
	- 使用 *String* 参数的构造方法来创建 **BigDecmal**
	- 原理
		- 不可变的
		- 把十进制小数扩大 N 倍让它**在整数上进行计算**，并保留相应的精度信息

## JDK 8 的新特性

1. Lambda 表达式
	- 函数式编程，允许将方法作为方法进行传入
2. 方法引用
	- 语法糖，可以直接引用已有对象和类的方法或构造器，与 lambda 配合使用
3. Stream API
	- 函数式编程风格、流抽象的方式来处理集合等数据结构
4. Optional 类
	- 避免空指针异常
5. Date Time API
	- 加强对日期与时间的处理 LocalDateTime、LocalDate、LocalTime 等

## 修饰符

- private：当前类
- protected：当前类和子类
- default：同一个包
- public：所有

## Java 中 final 作用是什么？

1. ==修饰类==
	- 表示这个类不能**被继承**，例如 String
	- 保证类的不可变性和安全性
2. ==修饰方法==
	- 不能在子类中**被重写**，例如 `Object::getClass`
3. ==修饰变量==
	- 基本类型：变量一旦被赋值就不能再**被修改**
	- 引用类型：这个引用变量不能**再指向**其他对象

## == 和 equals 的区别？

1. ==
	- 判断两个对象是否是**同一个对象**
	- 基础类型：比较**值**
	- 引用类型：比较**内存地址**
2. ==equals==
	- 判断两个对象**是否「相等」**
	- 如果没有重写：使用的值 `Object#equals`，和 == 的效果是一致的
	- 重写：逻辑通常比较的是**内容**

## hashcode 和 equals 方法有什么关系？

重写 equals 方法的类，通常也需要重写 hashCode 方法：

- ==一致性==
	- 如果两个对象 equals 方法比较为 true，那它们的 hashcode **必须相同**
- ==非一致性==
	- 如果两个对象的 hashcode 相同，它们 equals 方法比较结果**不一定**为 true
	- 因为可能存在哈希冲突

## final、finally、finalize的区别和用法?

- ==final==
	- 是一个**修饰符**
	- 可以被用来修饰变量（不能被**重新赋值**）、方法（不能**重写**）、类（不能**继承**）
- ==finally==
	- 是一个**关键字**
	- 其构造的代码块会在 try-catch 语句最后执行
- ==finalize==
	- 是一个 Object 定义的**方法**
	- 用于在 GC 将对象清除前做必要的清理工作

## 类和对象

### 加载顺序

静态变量 = 静态初始化块（仅在主类中执行一次） > 成员变量 > 初始化块 > 构造器

> [!INFO] 
> 由于静态变量和静态代码块的优先级相同，则**谁在前先执行谁**

如果存在继承的情况下，初始化顺序为：
1. 父类（静态变量、静态代码块）
2. 子类（静态变量、静态代码块）
3. 父类（实例变量、构造块）
4. 父类（构造函数）
5. 子类（实例变量、构造块）
6. 子类（构造函数）

### 内部类

| 内部类类型 | 可访问的资源           | 特点                                  |
| ---------- | ---------------------- | ------------------------------------- |
| 静态       | 静态资源               | -                                     |
| 成员       | 所有资源               | 本身不能再定义静态资源（JDK 16 以下） | 
| 局部       | 与当前方法访问资源相同 | -                                     |
| 匿名       | 与当前方法访问资源相同 | 无构造器、只能被创建一个实例          |

## 能讲一讲Java注解的原理吗?

注解从本质上来说就是一个**标记**，在反射解析时可以获取到这个标记以及设置的值。

元注解（用于注解其他注解）：
1. ==@Target==
	- 限制修饰的对象范围（Field、Class、Method...）
2. ==@Retention==
	- 指定注解的**生命周期**（存在阶段）
	- SOURCE（源码）：给编译器使用，不会写入 class 文件
	- CLASS（类加载）：类加载阶段丢失
	- RUNTIME（运行）：永久保存，运行期间可以反射获取
3. ==@Inherited==
	- 被标注的类型是被**继承**的
4. ==@Documented==

## 什么是反射？

反射是在**运行期**可以**动态**获取对象信息的能力，具有以下特性：
1. ==类信息访问==
	- 获取类的完整结构信息
	- 包括类名、包名、父类、实现的接口、方法、字段等
2. ==动态对象创建==
	- 反射API动态地创建对象实例：`Class::newInstance`
3. ==动态方法调用==
	- 在运行时调用对象的方法，包括**私有**方法：`Method::invoke`
4. ==访问和修改字段值==
	- 允许程序在运行时**访问和修改**对象的字段值，包括私有的

## 反射的原理是什么？

Java 会在编译期状态所有类，并将其元信息保存至 **Class 类对象**中。

因此在运行时可以通过类或者对象，获取到对应的 「Class 类对象」，从而进行反射。

## 谈谈你对泛型的理解？

1. ==代码复用==
	- 适用于多种数据类型执行相同的代码
	- 不用为每个类型都编写一份相同的代码
2. ==类型安全==
	- 不用强制转换（编译器会检查类型）
3. ==泛型擦除==
	- JDK 1.5 之后，为了兼容之前的版本，会在运行时进行泛型擦除
	- 即泛型只存在于**编译器**

## 深拷贝和浅拷贝的区别？

- ==浅拷贝==
	- 只复制对象本身和其内部的**值类型**字段
	- 对于引用类型的字段：将引用复制到新对象，指向**同一引用**对象
- ==深拷贝==
	- 完全拷贝一个对象
	- 对象内部的**所有**引用类型，在堆中的**也复制一份**

如图：

![Pasted image 20220328125735.png](/img/user/attachments/images/Pasted%20image%2020220328125735.png)

## 实现深拷贝的三种方法是什么？

1. 实现 Cloneable 接口并重写 clone() 方法
	- 要求对象及其所有引用类型字段都实现 **Cloneable** 接口
2. 使用序列化和反序列化
	- 例如 JSON 等
	- 要求对象及其所有引用类型字段都实现 **Serializable** 接口
3. 手动递归复制
	- 适用于对象结构复杂度不高的情况

## 说一下 serialVersionUID 的理解？

1. 如何生成的？
	- 根据类名、成员方法及属性生成的哈希值
	- 如果没有显式定义的话，JDK 会默认生成一个
2. 作用
	- 用来验证是否兼容
		- 在反序列时，会将字节流的  *serialVersionUID* 与反序列化的实体类的 *serialVersionUID* 相比，如果不一致将会失败
	- 用来控制是否兼容
		- 如果一个类可以向下兼容，则不修改该值
		- 否则，递增该值