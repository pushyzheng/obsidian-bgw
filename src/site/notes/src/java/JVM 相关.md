---
{"dg-publish":true,"dg-permalink":"JVM 相关","permalink":"/JVM 相关/","tags":["JVM"]}
---


#Java #JVM 

## JVM 的运行时数据区有哪些？都有什么作用？

1. 线程共享
	- 堆
		- 存放**对象**的实例
	- 方法区（HotSpot 中实现为元空间）
		- 存储已经被虚拟机加载的**类信息**、**常量**、**静态变量**等
2. 线程隔离
	- 程序计数器
		- 存储**字节码指令地址**，用于线程切换、循环控制等操作
	- 方法栈
		- 虚拟机方法栈：描述 Java **线程内存模型**，存放局部变量、操作数栈等
		- 本地方法栈：针对 **Native** 方法的方法栈
3. 直接内存
	- 避免 Java 堆到物理内存的拷贝，提高性能

## JVM 的堆分为哪几部分呢？

![Pasted image 20250725154136.png](/img/user/attachments/images/Pasted%20image%2020250725154136.png)

- ==新生代==
	- 分为：Eden区、Survivor 区
	- Eden区 存放大多数**新创建**的对象，经过minor GC后会晋升到Survivor 区或老年代
- ==老年代==
	- 存放过一次或多次 **Minor GC**仍存活的对象
- ==大对象区==
	- 需要大量连续内存空间的对象

## 永久代和元空间的区别？

1. 方法区是 Java 虚拟机中的规范，永久代和元空间是「方法区」的具体实现
2. 永久代
	- JDK **7** 及以前，分配在**堆**中
3. 元空间
	- JDK **8** 中，分配在**直接内存**

## JMM 中内存模型是怎样的？

JMM 即 Java 内存模型，是 JVM 的**内存抽象**，屏蔽不同操作系统的访问差异：

1. 存在两个内存区域：
	- ==主内存==
		- 被所有线程**共享**
		- 存储变量的本体
	- ==工作内存==
		- 每个线程**专用**
		- 存储变量的**副本**
2. 约定
	- 线程对变量操作必须在工作内存进行
	- 工作内存无法相互访问，变量值的传递只能通过主内存进行

## Java 方法栈（线程内存模型）是怎样的？

1. 栈帧
2. 局部变量表
	- 存储方法内的申请的局部变量
	- 基本类型直接存储，引用类型存储 ref
3. 操作数栈
	- 是一种后入先出的栈
	- 用于指令的计算
4. 动态链接
5. 方法返回地址

## 为什么需要 Survivor 区，还要两个?

1. 为什么需要？
	- 如果 Eden 区经过一次 Minor GC 存活的对象直接晋升到老年代，**很容易占满**
	- 目的
		- 减少直接晋升到老年代的对象
		- 减少 **Major GC** 的发生（只有默认经历了 **16** 次 Minor GC 才会晋升到老年代）
2. 为什么需要两个？
	- 使用复制算法，来解决**内存碎片化**

## 内存的分配策略有哪些？

1. 对象**优先**在 *Eden* 区上分配
2. 进入老年代的时机：
	- **大对象**（连续地址的数组或字符串）直接进入老年代：避免 Eden 区和 S 区来回复制
	- 长期存活（经历 from 到 to 区的转换 **16 次后**）的对象：将进入老年代
	- 动态对象年龄：如果 Survisor 区相同年龄所有对象总和大于 Survivor 区**一半**，年龄大于或大于该年龄直接晋升老年代

## 各种 GC 的区别

MinorGC、Major GC 是个俗称。

| Name     | MinorGC       | Major GC | Full GC                                              |
| -------- | ------------- | -------- | ---------------------------------------------------- |
| 回收区域 | 年轻代        | 通常和 *FullGC* 等价   | 整个堆空间（年轻代、老年代、以及 JDK8 之前的永久代） |
| 回收速度 | 快            | -       | 特别慢                                               |
| 触发时机 | *Eden* 区快满时 |  -        | 老年代快满、显示调用 *System.gc()* 等                  |

而 *Partial GC*（分代 GC）是：并**不收集整个** GC 堆的模式，分为：
- *Young GC*：只收集年轻代
- *Old GC*：只收集老年代，只有 **CMS** 是这个模式
- *Mixed GC*：收集整个年轻代和部分老年代，只有 **G1** 是这个模式

## JDK8 的默认垃圾收集器？

JDK 8 默认的垃圾收集器，并不是 CMS:

| JDK 版本 | 新生代            | 老年代     |
| -------- | ----------------- | ---------- |
| JDK8     | Parallel Scavenge | Serial Old |
| JDK9     | G1                | G1         |

## 内存溢出和内存泄漏的区别？

- ==内存溢出==（OOM）
	- 可用的内存不足，无法再**申请**内存空间
	- 解决方案：调整堆空间的大小，或根据条件增加机器
	- 除了**程序计数器**不会发生，其他区域**都**可能会发生 OOM
- ==内存泄漏==
	- 对象没有及时地**释放**，一直没有被 GC，通常是代码本身问题导致
	- 最终将会导致内存溢出

## Java 的引用类型都有哪些？

Java 的引用一共有四种：
1. ==强引用==
	- 普遍存在的赋值
	- 永远不会回收被强引用的对象
2. ==软引用==
	- 通过 *SoftReference* 类来实现
	- 在 **OOM 前**进行回收
	- 应用：内存敏感的缓存
3. ==弱引用==
	- 通过 *WeakReference* 实现
	- **下一次 GC 时**回收
	- 应用：缓存的选择
4. ==虚引用==
	- 通过 *PhantomReference + ReferenceQueue* 来实现，无法通过引用直接获取到对象
	- 应用：当 GC 回收对象前，如果其有虚引用，会把该引用加入到关联的队列中，所以可以用来**监控对象的销毁**

## 什么是指令重排序？

- JVM 会适当地对指令进行重排，以提高处理器的执行效率
- 直接运行当前能立即执行的后续指令，避开获取下一条指令所需数据时造成的等待

## volatile 是怎么防止指令重排序的？

1. [内存屏障](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Fconcept%2F%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C)
	- 是一种 CPU 指令，用来控制重排序和内存可见性的问题
2. 类型（Load 为读屏障，Store 为写屏障）
	- LoadLoad
	- LoadStore
	- StoreLoad
	- StoreStore

举例，A 先写入 volatile 遍历 X，B 后读取 volatile 遍历 X，则会添加一个内存屏障：

```java
// 表示：在 Read X 及后续所有读取操作执行前
// 保证 Write X 的写入对所有处理器可见
[Write X] StoreLoad [Read X]
```