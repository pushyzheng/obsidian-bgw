---
{"dg-publish":true,"dg-permalink":"JVM 垃圾回收","permalink":"/JVM 垃圾回收/","tags":["JVM"]}
---


#Java #JVM 

## Java 中垃圾回收机制中如何判断对象需要回收?

有两种方式：
1. ==引用计数算法==
	- 为**每个**对象分配一个引用计数器: 保存该对象被引用的次数，当引用次数为 **0** 时，代表可以被回收
	- 缺点：无法解决循环引用[^1]的问题
2. ==可达性分析==
	- 与 GC Roots 没有**直接或者间接**的联系，则视为可回收对象(不可达)
	- GC Roots对象
		- 虚拟机栈（栈帧中的本地变量表）中引用的对象
		- 方法区中类静态属性引用的对象
		- 本地方法栈中JNI引用的对象
		- 活跃线程的引用

## 常见的垃圾收集算法

1. ==标记-清除算法==
	- 原理：通过可达性分析标记出要回收对象，然后**统一回收**被标记的对象
	- 优点：简单
	- 缺点：效率低、容易产生**内存碎片**（导致申请大块内存没有连续的空间）
	- 适合区域：老年代
2. ==复制算法==
	- 原理：将内存**分成两块**，每次申请只用其中一块，回收时将存活的对象复制到另一块
	- 优点：简单高效，不会有内存碎片
	- 缺点：需要双倍的空间，不适用于存活率高的场景
	- 适合区域：**新生代**
3. ==标记整理算法==
	- 原理：和标记-清除算法类似，但标记之后不会直接清理，而是将存活对象**移动到**内存一端(整理)
	- 优点：不会产生内存碎片
	- 缺点：效率低
	- 适合区域：老年代
4. ==分代回收算法==
	- 将内存按照对象的**生存周期**，划分成了新生代和老年代
	- 根据不同区域，采取不同的回收算法

## 标记清除算法的缺点是什么？

1. 效率
	- 标记和清除过程的效率都不高
2. 空间问题
	- 标记清除之后会产生大量不连续的**内存碎片**
	- 导致需要分配**较大**对象时无法找到足够的**连续**内存

## 能说一下分代收集算法吗？

1. 是根据年轻代和老年代的**特点**，来选择特定的收集算法
2. 年轻代
	- 适合使用**复制**算法
	- 对象**存活率低**
	- 可以有老年代为此**担保内存**
3. 老年代
	- 适合使用标记-清除 or 标记-整理算法
	- 对象存活率较高，频繁复制降低性能
	- 没有额外的区域为此担保

## 垃圾回收器都有哪些？

- ==Serial收集器==
	- 新生代**单线程**，采用复制算法
- ==ParNew收集器==
	- 新生代收**并行**集器，采用复制算法
- ==Parallel Scavenge收集器==
	- 新生代**并行**收集器，采用复制算法
- ==Serial Old收集器==
	- 老年代**单线程**收集器，采用标记-整理算法
- ==Parallel Old收集器==
	- 老年代**并行**收集器，采用标记-整理算法
- ==CMS(Concurrent Mark Sweep)收集器==
	- 老年代并行收集器，采用**标记-清除**算法
	- 具有高并发、低停顿的特点
- ==G1(Garbage First)收集器==
	- 堆并行收集器，采用标记-整理算法
	- 回收的范围是**整个堆**

## 垃圾收集器并发和并行的区别？

- **并发**：GC 线程和用户线程可以在某段时间内，一起在运行
- **并行**：多个 GC Worker 一起进行垃圾收集（用户线程并不运行）

## 垃圾回收器 CMS 和 G1的区别?

1. 使用范围不同
	- CMS 是老年代收集器，可以配合其他新生代一起使用
	- G1 不需要结合
2. STW的时间
	- 以最小停顿时间为目标
	- 可预测垃圾回收的停顿时间
3. 垃圾碎片
	- CMS采用标记-清除，容易产生内存碎片
4. 垃圾回收的过程
5. CMS会产生浮动垃圾
	- 产生浮动垃圾过多时会退化为serial old

## minorGC、majorGC、FullGC 的区别？

- ==Minor GC (Young GC)==
	- 只针对**年轻代**进行回收：Eden区、两个 Survivor区
	- 时机：当Eden区空间不足时，将Eden区和另一个S区对象移动到另一个 S 区或老年代
- ==Major GC==
	- 主要针对**老年代**进行回收
	- 时机：老年代空间不足时
- ==Full GC==
	- 对**整个堆**内存进行回收

## Full GC 有哪些触发条件？

1. System.gc()：手动进行触发
2. 老年代空间不足
3. **空间担保**失败：年轻代向老年代空间担保失败
4. JDK 1.7 前**永久代**空间不足
5. *Concurrent Mode Failure*

[^1]: 即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收
