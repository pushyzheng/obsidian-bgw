---
{"dg-publish":true,"dg-permalink":"Java IO","permalink":"/Java IO/"}
---


#Java #Java基础 

## 字节流和字符流的区别？

- ==字节流==
	- 基本单位为字节，采用 **ASCII** 编码；
	- InputStream/OutputStream
- ==字符流==
	- 其底层仍然为字节流，采用 **Unicode** 编码（默认的具体实现为 UTF-8）
	- Reader/Writer

## 什么是 I/O？

I/O 就是指**内存**与**外部设备**之间的交互，即数据的拷贝：
1. 网络 I/O ：**网卡**与内存之间的输入输出
2. 磁盘 I/O ：**磁盘**和内存之间的输入输出

I/O 会存在两个阶段：

-   **等待就绪（可读/可写）**：等待字节流可读取/可写入
-   **数据拷贝**：真正开始内核态与用户态之间的数据拷贝

## 五种 I/O 模型？

五种 I/O 模型区别如下：

| Name         | 等待就绪 | 数据拷贝 | 特点                           |
| ------------ | -------- | -------- | ------------------------------ |
| 阻塞 I/O     | **阻塞** | 同步     | -                              |
| 非阻塞 I/O   | 非阻塞   | 同步     | 非阻塞                         |
| I/O 复用     | 非阻塞   | 同步     | 多路复用，单一线程监听多个连接 |
| 信号驱动 I/O | 非阻塞   | 同步     | 信号驱动                               |
| 异步 I/O     | 非阻塞   | **异步** | 真正的异步                               |

## 传统 I/O 和 NIO 之间的区别

1. 传统 I/O
	- 阻塞，面向**流**（Stream）
2. NIO
	- **非**阻塞，面向**缓冲**（Buffer）
	- 有 Channel 和 Selector，允许用**一个**线程来监听**多个**通道（客户端连接读写事件）

## BIO、NIO、AIO 有什么区别？

1. ==BIO（同步阻塞 I/O）==
	- 编程模型简单：让单个线程专注于一个连接，有更高的开发效率和可维护性
	- 性能瓶颈：无法应对高并发的场景
2. ==NIO（同步非阻塞 I/O）==，从 JDK1.4 引入的：
	- 同时支持：阻塞和非阻塞两种模式
	- 面向**缓冲**
		- 并抽象出 Buffer、Channel、Selector 三大组件
	- 减少**内存复制**
		- DirectBuffer：堆 → 直接内存
		- MapperedByteBuffer：**零拷贝**，内核态 → 用户态
	- 节省资源：节省出更多的 **CPU 资源**，更好地应对高并发的场景
	- 缺点：**编程难度比较高**，但是可以基于高级封装的框架开发（Netty、Reactor）
3. ==AIO==：即五种模型的**异步 I/O** 的实现，在 JDK7 后引入
	- 异步非阻塞模型：I/O 的两个阶段都不会有阻塞发生
	- 基于事件和回调机制
	- 应用不是很广泛

## NIO 是怎么实现的？

1. ==Buffer==
	- 即缓冲区
	- 当I/O事件**就绪**时，可以通过**写到缓冲区**保证 I/O 的成功，而无需阻塞等待
2. ==Channel==
	- 即通道，是访问 Buffer 的接口
	- 类似于 Stream，数据总是**从通道读取**到缓冲区中，或者从缓冲区**写入到通道**中
3. ==Selector==
	- 即选择器，实现I/O**多路复用**，是非阻塞的核心
	- 用于单个线程监听**多个**客户端的连接、可读、可写事件
	- **避免了阻塞**同时减少了不必要的线程消耗
