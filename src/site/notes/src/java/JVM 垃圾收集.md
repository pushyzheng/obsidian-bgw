---
{"dg-publish":true,"dg-permalink":"JVM 垃圾收集","permalink":"/JVM 垃圾收集/"}
---


#Java #JVM 

## Java 中垃圾回收机制中如何判断对象需要回收?

有两种方式：
1. [引用计数算法](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95)
	- 保存对象被引用的次数
	- 当**引用次数为 0** 时，代表可以被回收。
2. [可达性分析](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2F%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90)
	- 与 GC Roots 没有**直接或者间接的联系**，则视为可回收对象

## 常见的垃圾收集算法

[垃圾收集的算法](obsidian://open?vault=%E7%AC%94%E8%AE%B0&file=src%2Funarchived%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E7%AE%97%E6%B3%95) 有三种：
1. 标记清除
	- 优点：简单
	- 缺点：容易产生**内存碎片**
	- 适合区域：老年代
2. 复制
	- 优点：简单高效，不会有内存碎片
	- 缺点：需要双倍的空间，不适用于存活率高的场景
	- 适合区域：**新生代**
3. 标记整理
	- 优点：不会产生内存碎片
	- 缺点：效率低
	- 适合区域：老年代

## 能说一下分代收集算法吗？

1. 是根据年轻代和老年代的**特点**，来选择特定的收集算法
2. 年轻代
	- 适合使用**复制**算法
	- 对象**存活率低**
	- 可以有老年代为此**担保内存**
3. 老年代
	- 适合使用标记-清除 or 标记-整理算法
	- 对象存活率较高，频繁复制降低性能
	- 没有额外的区域为此担保

## 垃圾收集器并发和并行的区别？

- **并发**：GC 线程和用户线程可以在某段时间内，一起在运行
- **并行**：多个 GC Worker 一起进行垃圾收集（用户线程并不运行）

## Full GC 有哪些触发条件？

1. System.gc()：手动进行触发
2. 老年代空间不足
3. **空间担保**失败：年轻代向老年代空间担保失败
4. JDK 1.7 前**永久代**空间不足
5. *Concurrent Mode Failure*