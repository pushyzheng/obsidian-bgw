---
{"dg-publish":true,"dg-permalink":"类加载机制常见问题","permalink":"/类加载机制常见问题/"}
---


#JVM 

## 1. 类加载机制的过程？

![jvm-类加载机制.png|500](/img/user/attachments/images/jvm-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png)

1. 加载
	- 通过全限定名加载**二进制字节流**
2. 验证
	- 文件格式（魔数、版本）、元数据、字节码验证
3. 准备
	- 设置类的静态变量（在方法区分配）**默认值**，如 int：0
4. 解析
	- 将**符号**引用替换**直接**引用
5. 初始化
	- 执行类构造器 init 法，真正初始化

## 2. 什么是双亲委派机制？

双亲委派（*Parents delegate*）是指：除启动类加载器外其他加载器在加载 .class 文件时：
- 首先**委托给父类**加载器进行加载
- 只有当祖先无法胜任时，才会真正加载

整个过程类似于「递归」：

![jvm-双亲委派机制.png|400](/img/user/attachments/images/jvm-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png)

### 有什么作用？

- **避免类的重复加载**：防止内存中出现多份同样的字节码，让类正确地统一地加载
- **保证 Java 程序稳定运行**：核心 API 定义的类型不会被篡改，如 *Object* 只会由启动类加载来完成

### 具体实现？

虽然提到子类和父类，但是加载器之间的关系**不是继承，而是组合**。

![Pasted image 20220330002349.png|500](/img/user/attachments/images/Pasted%20image%2020220330002349.png)

### 有哪些破坏双亲委派的案例？

1. 重写 *ClassLoader* 的 **loadClass** 方法，就可以破坏委派的逻辑
2. SPI 机制，如 **JDBC** 接口的实现：启动类加载器（只加载 *<JAVA_HOME>\lib* 的路径）只能委托子类来加载数据库厂商们提供的具体实现（在我们用户定义的 classpath 中）
3. **热部署**
4. JDK9 引入的**模块化**

